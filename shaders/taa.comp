#version 460

#include "colors.glsl"

layout (local_size_x = 16, local_size_y = 16) in;


layout (set = 0, binding = 0) uniform sampler2D currentFrame;    // Your drawImage result
layout (set = 0, binding = 1) uniform sampler2D historyFrame;    // Previous frame
layout (set = 0, binding = 2) uniform sampler2D velocityBuffer;  // Motion vectors

layout (rgba16f, set = 0, binding = 3) uniform image2D outputImage;  // taaResult

layout (push_constant) uniform PushConstants {
    int width;
    int height;
    vec2 texelSize;
    float minBlend;
    float maxBlend;
} push;

struct NeighborhoodStats {
    vec3 min;
    vec3 max;
    vec3 mean;
    vec3 variance;
};

void getSampleBounds(vec2 uv, out NeighborhoodStats stats) {
    stats.min = vec3(1.0);
    stats.max = vec3(0.0);
    stats.mean = vec3(0.0);
    stats.variance = vec3(0.0);

    float totalWeight = 0.0;

    for (int x = -1; x <= 1; x++) {
        for (int y = -1; y <= 1; y++) {
            vec2 offset = vec2(x, y) * push.texelSize;
            vec3 sampleRGB = texture(currentFrame, uv + offset).rgb;
            vec3 YCoCgSample = RGBToYCoCg(sampleRGB);

            float weight = 1.0 / (1.0 + abs(x) + abs(y));

            stats.mean += YCoCgSample * weight;
            totalWeight += weight;

            // Still track min/max for fallback
            stats.min = min(stats.min, YCoCgSample);
            stats.max = max(stats.max, YCoCgSample);
        }
    }
    stats.mean /= totalWeight;

    for (int x = -1; x <= 1; x++) {
        for (int y = -1; y <= 1; y++) {
            vec2 offset = vec2(x, y) * push.texelSize;
            vec3 sampleRGB = texture(currentFrame, uv + offset).rgb;
            vec3 YCoCgSample = RGBToYCoCg(sampleRGB);

            float weight = 1.0 / (1.0 + abs(x) + abs(y));
            vec3 diff = YCoCgSample - stats.mean;
            stats.variance += diff * diff * weight;
        }
    }
    stats.variance /= totalWeight;
}

void main() {
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    if (pixel.x >= push.width || pixel.y >= push.height) {
        return;
    }
    vec2 uv = (vec2(pixel) + 0.5) * push.texelSize;

    vec3 currentColorRGB = texture(currentFrame, uv).rgb;
    vec3 currentColor = RGBToYCoCg(currentColorRGB);

    // Motion Vector Reprojection
    // velocity [-1, 1]
    vec2 velocity = texture(velocityBuffer, uv).rg;
    vec2 historyUv = uv - velocity;

    // History UV Validation
    bool validHistory = all(greaterThanEqual(historyUv, vec2(0.0))) && all(lessThan(historyUv, vec2(1.0)));

    // Neighborhood Clamping
    NeighborhoodStats stats;
    getSampleBounds(uv, stats);
    vec3 sigma = sqrt(max(vec3(0.0), stats.variance));
    vec3 minColor = stats.mean - sigma;
    vec3 maxColor = stats.mean + sigma;

    vec3 historyColor = validHistory ? RGBToYCoCg(texture(historyFrame, historyUv).rgb) : currentColor;
    // Clamp to the same limits as current color
    historyColor = clamp(historyColor, minColor, maxColor);

    float velocityLength = length(velocity);
    float blend = mix(push.minBlend, push.maxBlend, smoothstep(0.0, 0.2, velocityLength));
    blend = validHistory ? blend : 1.0;

    vec3 finalColorYCoCg = mix(historyColor, currentColor, blend);
    vec3 finalColorRGB = YCoCgToRGB(finalColorYCoCg);

    imageStore(outputImage, pixel, vec4(finalColorRGB, 1.0));
}