#version 460

#include "colors.glsl"

layout (local_size_x = 16, local_size_y = 16) in;

layout (set = 0, binding = 0) uniform sampler2D drawImage;
layout (set = 0, binding = 1) uniform sampler2D drawHistory;
layout (set = 0, binding = 2) uniform sampler2D depthImage;
layout (set = 0, binding = 3) uniform sampler2D depthHistory;
layout (set = 0, binding = 4) uniform sampler2D velocityBuffer;
layout (rgba16f, set = 0, binding = 5) uniform image2D outputImage;

layout (push_constant) uniform PushConstants {
    int width;
    int height;
    vec2 texelSize;
    float minBlend;
    float maxBlend;
    float velocityWeight;
    float depthWeight;
} push;

struct NeighborhoodStats {
    vec3 min;
    vec3 max;
    vec3 mean;
    vec3 variance;
};

float getVelocityConfidence(vec2 uv, vec2 centralVelocity) {
    // Returns confidence (0-1) based on neighborhood velocity consistency.
    // Lower values indicate motion discontinuities or disocclusions.
    float confidence = 1.0;
    float totalWeight = 0.0;

    for (int x = -1; x <= 1; x++) {
        for (int y = -1; y <= 1; y++) {
            if (x == 0 && y == 0) continue;

            vec2 offset = vec2(x, y) * push.texelSize;
            vec2 neighborVelocity = texture(velocityBuffer, uv + offset).rg;
            float velocityDiff = length(neighborVelocity - centralVelocity);
            float weight = 1.0 / (1.0 + abs(x) + abs(y));

            confidence -= weight * velocityDiff * push.velocityWeight;
            totalWeight += weight;
        }
    }

    confidence /= totalWeight;
    return clamp(confidence, 0.0, 1.0);
}

float getDepthConfidence(vec2 uv, vec2 historyUv) {
    // Calculates confidence (0-1) based on depth consistency between current and history samples.
    // Compares history depth against current neighborhood depth range to detect disocclusions
    // and depth discontinuities. Lower values indicate significant depth changes or z-fighting.
    float currentDepth = texture(depthImage, uv).r;
    float historyDepth = texture(depthHistory, historyUv).r;

    // Get neighborhood depth range
    float minDepth = currentDepth;
    float maxDepth = currentDepth;

    for (int x = -1; x <= 1; x++) {
        for (int y = -1; y <= 1; y++) {
            vec2 offset = vec2(x, y) * push.texelSize;
            float neighborDepth = texture(depthImage, uv + offset).r;
            minDepth = min(minDepth, neighborDepth);
            maxDepth = max(maxDepth, neighborDepth);
        }
    }

    // Check if history depth is within current neighborhood range
    float depthRange = maxDepth - minDepth;
    float depthDiff = abs(historyDepth - currentDepth);

    // Calculate confidence based on relative depth difference
    float relativeDepthDiff = depthDiff / (depthRange + 0.0001);
    return exp(-relativeDepthDiff * push.depthWeight);
}

void getSampleBounds(vec2 uv, out NeighborhoodStats stats) {
    // Computes color bounds for the 3x3 neighborhood in YCoCg space.
    // Returns statistics (min/max/mean/variance) used for temporal clamping.
    // Uses weighted samples where center pixels contribute more than edges.
    // Variance is used to dynamically adjust clamping bounds based on local contrast.
    stats.min = vec3(1.0);
    stats.max = vec3(0.0);
    stats.mean = vec3(0.0);
    stats.variance = vec3(0.0);

    float totalWeight = 0.0;

    for (int x = -1; x <= 1; x++) {
        for (int y = -1; y <= 1; y++) {
            vec2 offset = vec2(x, y) * push.texelSize;
            vec3 sampleRGB = texture(drawImage, uv + offset).rgb;
            vec3 YCoCgSample = RGBToYCoCg(sampleRGB);

            float weight = 1.0 / (1.0 + abs(x) + abs(y));

            stats.mean += YCoCgSample * weight;
            totalWeight += weight;

            // Still track min/max for fallback
            stats.min = min(stats.min, YCoCgSample);
            stats.max = max(stats.max, YCoCgSample);
        }
    }
    stats.mean /= totalWeight;

    for (int x = -1; x <= 1; x++) {
        for (int y = -1; y <= 1; y++) {
            vec2 offset = vec2(x, y) * push.texelSize;
            vec3 sampleRGB = texture(drawImage, uv + offset).rgb;
            vec3 YCoCgSample = RGBToYCoCg(sampleRGB);

            float weight = 1.0 / (1.0 + abs(x) + abs(y));
            vec3 diff = YCoCgSample - stats.mean;
            stats.variance += diff * diff * weight;
        }
    }
    stats.variance /= totalWeight;
}

void main() {
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    if (pixel.x >= push.width || pixel.y >= push.height) {
        return;
    }
    vec2 uv = (vec2(pixel) + 0.5) * push.texelSize;

    vec3 currentColorRGB = texture(drawImage, uv).rgb;
    vec3 currentColor = RGBToYCoCg(currentColorRGB);

    // Motion Vector Reprojection
    vec2 velocity = texture(velocityBuffer, uv).rg;
    vec2 historyUv = uv - velocity;

    // History Rejection (Section 4.1 of the Survey)
    bool validHistory = all(greaterThanEqual(historyUv, vec2(0.0))) && all(lessThan(historyUv, vec2(1.0)));

    // Velocity Weighting (Reject if variation too great w/ adjacent velocities, helps with edges and disocclusion)
    float velocityConfidence = getVelocityConfidence(uv, velocity);

    float depthConfidence = validHistory ? getDepthConfidence(uv, historyUv) : 0.0;

    float confidence = velocityConfidence * depthConfidence;

    // Neighborhood Clamping
    NeighborhoodStats stats;
    getSampleBounds(uv, stats);
    vec3 sigma = sqrt(max(vec3(0.0), stats.variance));
    sigma.x *= 1.0;       // Luma (Y)
    sigma.yz *= 1.25;     // Chroma (Co,Cg)
    vec3 minColor = stats.mean - sigma;
    vec3 maxColor = stats.mean + sigma;
    minColor = max(minColor, stats.min);
    maxColor = min(maxColor, stats.max);

    vec3 historyColor = validHistory ? RGBToYCoCg(texture(drawHistory, historyUv).rgb) : currentColor;
    // Clamp to the same limits as current color
    historyColor = clamp(historyColor, minColor, maxColor);

    float velocityLength = length(velocity);
    float baseBlend = mix(push.minBlend, push.maxBlend, smoothstep(0.0, 0.2, velocityLength));

    float blend = mix(max(baseBlend, 0.5), baseBlend, confidence);
    blend = validHistory ? blend : 1.0;

    vec3 finalColorYCoCg = mix(historyColor, currentColor, blend);
    vec3 finalColorRGB = YCoCgToRGB(finalColorYCoCg);

    imageStore(outputImage, pixel, vec4(finalColorRGB, 1.0));
}