#version 460

#include "colors.glsl"

layout (local_size_x = 16, local_size_y = 16) in;

layout (set = 0, binding = 0) uniform sampler2D drawImage;
layout (set = 0, binding = 1) uniform sampler2D drawHistory;
layout (set = 0, binding = 2) uniform sampler2D depthImage;
layout (set = 0, binding = 3) uniform sampler2D depthHistory;
layout (set = 0, binding = 4) uniform sampler2D velocityBuffer;
layout (rgba16f, set = 0, binding = 5) uniform image2D outputImage;

layout (push_constant) uniform PushConstants {
    int width;
    int height;
    vec2 texelSize;
    float minBlend;
    float maxBlend;
    float velocityWeight;
    float depthWeight;
    bool bEnabled;
} push;

void getNeighborhoodBounds(vec2 uv, out vec3 minColor, out vec3 maxColor) {
    // https://developer.download.nvidia.com/gameworks/events/GDC2016/msalvi_temporal_supersampling.pdf

    const int radius = 1;
    const int sampleCount = (2 * radius + 1) * (2 * radius + 1);
    vec3 samples[9]; // hard-coded

    // Track min/max for box clamping
    minColor = vec3(1.0);
    maxColor = vec3(0.0);

    // First moment (mean)
    vec3 mean = vec3(0.0);
    int idx = 0;
    for (int y = -radius; y <= radius; y++) {
        for (int x = -radius; x <= radius; x++) {
            vec2 offset = vec2(x, y) * push.texelSize;
            vec3 sampleRGB = texture(drawImage, uv + offset).rgb;
            vec3 sampleYCoCg = RGBToYCoCg(sampleRGB);

        samples[idx++] = sampleYCoCg;
        mean += sampleYCoCg;

        // Track min/max for box clipping
        minColor = min(minColor, sampleYCoCg);
        maxColor = max(maxColor, sampleYCoCg);
        }
    }
    mean /= float(sampleCount);

    // Second moment (variance)
    vec3 variance = vec3(0.0);
    for (int i = 0; i < sampleCount; i++) {
        vec3 diff = samples[i] - mean;
        variance += diff * diff;
    }
    variance /= float(sampleCount);

    // Standard deviation
    vec3 stdDev = sqrt(variance);

    // adjustible values, maybe move to push constant
    float gammaLuma = 1.0 + mean.x * 2.0; // 1.0
    vec2 gammaChroma = vec2(1.25) + abs(mean.yz) * 2.0; // 1.25

    stdDev.x *= gammaLuma;
    stdDev.yz *= gammaChroma;

    vec3 boxMin = mean - stdDev;
    vec3 boxMax = mean + stdDev;

    minColor = max(boxMin, minColor);
    maxColor = min(boxMax, maxColor);
}

void main() {
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    if (pixel.x >= push.width || pixel.y >= push.height) {
        return;
    }
    vec2 uv = (vec2(pixel) + 0.5) * push.texelSize;
    vec3 currentColorRGB = texture(drawImage, uv).rgb;
    if (!push.bEnabled){
        imageStore(outputImage, pixel, vec4(currentColorRGB, 1.0));
        return;
    }

    vec3 currentColor = RGBToYCoCg(currentColorRGB);

    vec2 velocity = texture(velocityBuffer, uv).rg;
    vec2 historyUv = uv - velocity;

    bool validHistory = all(greaterThanEqual(historyUv, vec2(0.0))) && all(lessThan(historyUv, vec2(1.0)));
    vec3 historyColor = validHistory ? RGBToYCoCg(texture(drawHistory, historyUv).rgb) : currentColor;

    // Variance Clipping
    vec3 minColor, maxColor;
    getNeighborhoodBounds(uv, minColor, maxColor);
    historyColor = clamp(historyColor, minColor, maxColor);

    // Simple static blend factor
    float blend = validHistory ? 0.1 : 1.0; // 10% current, 90% history when valid

    // Blend and convert back to RGB
    vec3 finalColorYCoCg = mix(historyColor, currentColor, blend);
    vec3 finalColorRGB = YCoCgToRGB(finalColorYCoCg);

    imageStore(outputImage, pixel, vec4(finalColorRGB, 1.0));
}