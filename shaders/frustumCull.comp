#version 460

#extension GL_EXT_buffer_reference : require

layout(local_size_x = 64) in;

struct MeshBounds
{
    vec3 position;
    float radius;
};

struct VkDrawIndexedIndirectCommand
{
    uint indexCount;
    uint instanceCount;
    uint firstIndex;
    int  vertexOffset;
    uint firstInstance;
};

layout(buffer_reference, std430) readonly buffer MeshBoundsBuffer
{
    MeshBounds meshBounds[];
};

layout(buffer_reference, std430) buffer CommandBuffer
{
    VkDrawIndexedIndirectCommand commands[];
};

struct Model
{
    mat4 modelMatrix1;
    mat4 modelMatrix2;
};

layout(buffer_reference, std430) buffer ModelBuffer
{
    Model modelMatrices[];
};
layout(buffer_reference, std430) buffer MeshIndexBuffer
{
    int indices[];
};


layout(set = 0, binding = 0) uniform bufferData
{
    MeshBoundsBuffer boundsBuffer;
    CommandBuffer commandBuffer;
    uint commandBufferCount;
    ModelBuffer modelMatrixBuffer;
    MeshIndexBuffer meshIndices;
    vec3 padding;
} buffers;

layout (std140, set = 1, binding = 0) uniform SceneData {
    mat4 view;
    mat4 proj;
    mat4 viewProj;
    vec4 cameraPos;
    mat4 viewProjCameraLookDirection;

    mat4 invView;
    mat4 invProjection;
    mat4 invViewProjection;

    mat4 prevView;
    mat4 prevProj;
    mat4 prevViewProj;
    vec4 jitter;
    vec2 renderTargetSize;
    int frameNumber; // either 0 or 1
    int pad;
} sceneData;


vec3 getScale(mat4 m) {
    return vec3(
    length(m[0].xyz),
    length(m[1].xyz),
    length(m[2].xyz)
    );
}


int checkIsVisible(mat4 mat, vec3 origin, float radius)
{
    uint plane_index = 0;
    for (uint i = 0; i < 3; ++i)
    {
        for (uint j = 0; j < 2; ++j, ++plane_index)
        {
            if (plane_index == 2 || plane_index == 3)
            {
                continue;
            }
            const float sign  = (j > 0) ? 1.f : -1.f;
            vec4        plane = vec4(0, 0, 0, 0);
            for (uint k = 0; k < 4; ++k)
            {
                plane[k] = mat[k][3] + sign * mat[k][i];
            }
            plane.xyzw /= sqrt(dot(plane.xyz, plane.xyz));
            if (dot(origin, plane.xyz) + plane.w + radius < 0)
            {
                return 0;
            }
        }
    }
    return 1;
}

void main()
{
    uint invocationId = gl_GlobalInvocationID.x;
    if (invocationId >= buffers.commandBufferCount) { return; }

    uint modelMatrixId = buffers.commandBuffer.commands[invocationId].firstInstance;
    Model models = buffers.modelMatrixBuffer.modelMatrices[modelMatrixId];
    mat4 currModel;
    mat4 prevModel;
    if(sceneData.frameNumber == 0){
        currModel = models.modelMatrix1;
        prevModel = models.modelMatrix2;
    } else {
        currModel = models.modelMatrix2;
        prevModel = models.modelMatrix1;
    }

    int meshBoundIndex = buffers.meshIndices.indices[invocationId];
    MeshBounds bounds = buffers.boundsBuffer.meshBounds[meshBoundIndex];

    vec3 position = bounds.position;
    float radius = bounds.radius;
    vec3 scale = getScale(currModel);
    float maxScale = max(max(scale.x, scale.y), scale.z);

    // transform position to clip space
    position = vec3(currModel * vec4(position, 1.0));
    // scale radius w/ model scale
    float worldRadius = radius * maxScale;

    int visible = checkIsVisible(sceneData.viewProj, position, worldRadius);

    // only ever modify instanceCount to frustum Cull
    buffers.commandBuffer.commands[invocationId].instanceCount = uint(visible);
}