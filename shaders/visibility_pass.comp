#version 460

#extension GL_EXT_buffer_reference : require

#include "scene.glsl"
#include "structure.glsl"

layout(local_size_x = 64) in;

// layout (std140, set = 0, binding = 0) uniform SceneData - scene.glsl

layout (set = 1, binding = 0) uniform VisibilityPassData
{
    Instances instances;
    Models models;
    PrimitiveData primitives;
    CommandBuffer opaqueCommands;
    CommandBuffer transparentCommands;
    DrawCounts drawCounts;
} visibilityPassData;


layout (push_constant) uniform PushConstants {
    int enabledFrustumCull;
    int shadowPass;
} push;

// todo make this only require a single dot product
int checkIsVisible(mat4 mat, vec3 origin, float radius)
{
    uint plane_index = 0;
    for (uint i = 0; i < 3; ++i)
    {
        for (uint j = 0; j < 2; ++j, ++plane_index)
        {
            if (plane_index == 2 || plane_index == 3)
            {
                continue;
            }
            const float sign  = (j > 0) ? 1.f : -1.f;
            vec4        plane = vec4(0, 0, 0, 0);
            for (uint k = 0; k < 4; ++k)
            {
                plane[k] = mat[k][3] + sign * mat[k][i];
            }
            plane.xyzw /= sqrt(dot(plane.xyz, plane.xyz));
            if (dot(origin, plane.xyz) + plane.w + radius < 0)
            {
                return 0;
            }
        }
    }
    return 1;
}

void main()
{
    uint invocationId = gl_GlobalInvocationID.x;
    if (invocationId >= visibilityPassData.drawCounts.indirectCount.limit) { return; }

    Instance instanceData = visibilityPassData.instances.instanceArray[invocationId];
    if (instanceData.bIsDrawn == 0) { return; }

    Model model = visibilityPassData.models.modelArray[instanceData.modelIndex];
    Primitive primitive = visibilityPassData.primitives.primitiveArray[instanceData.primitiveDataIndex];
    bool bTransparent = primitive.bHasTransparent != 0;


    if (push.shadowPass == 1){
        // "Dont Cast Shadows" flag
        if (model.flags.y == 0){ return; }

        VkDrawIndexedIndirectCommand cmd;
        cmd.indexCount = primitive.indexCount;
        cmd.instanceCount = 1;
        cmd.firstIndex = primitive.firstIndex;
        cmd.vertexOffset = primitive.vertexOffset;
        cmd.firstInstance = invocationId;

        if (bTransparent) {
            uint outputIndex = atomicAdd(visibilityPassData.drawCounts.indirectCount.transparentCount, 1);
            visibilityPassData.transparentCommands.commandArray[outputIndex] = cmd;
        } else {
            uint outputIndex = atomicAdd(visibilityPassData.drawCounts.indirectCount.opaqueCount, 1);
            visibilityPassData.opaqueCommands.commandArray[outputIndex] = cmd;
        }
        return;
    } else {
        // "Don't draw" flag
        if (model.flags.x == 0){ return; }
    }

    if (push.enabledFrustumCull == 0){
        VkDrawIndexedIndirectCommand cmd;
        cmd.indexCount = primitive.indexCount;
        cmd.instanceCount = 1;
        cmd.firstIndex = primitive.firstIndex;
        cmd.vertexOffset = primitive.vertexOffset;
        cmd.firstInstance = invocationId;

        if (bTransparent) {
            uint outputIndex = atomicAdd(visibilityPassData.drawCounts.indirectCount.transparentCount, 1);
            visibilityPassData.transparentCommands.commandArray[outputIndex] = cmd;
        } else {
            uint outputIndex = atomicAdd(visibilityPassData.drawCounts.indirectCount.opaqueCount, 1);
            visibilityPassData.opaqueCommands.commandArray[outputIndex] = cmd;
        }
        return;
    }

    vec3 position = primitive.meshBounds.position;
    float radius = primitive.meshBounds.radius;
    vec3 scale = vec3(length(model.currentModelMatrix[0].xyz),
    length(model.currentModelMatrix[1].xyz),
    length(model.currentModelMatrix[2].xyz));
    float maxScale = max(max(scale.x, scale.y), scale.z);
    position = vec3(model.currentModelMatrix * vec4(position, 1.0));
    float worldRadius = radius * maxScale;


    int visible = checkIsVisible(sceneData.viewProj, position, worldRadius);

    //if (visible != 0) {
    VkDrawIndexedIndirectCommand cmd;
    cmd.indexCount = primitive.indexCount;
    cmd.firstIndex = primitive.firstIndex;
    cmd.vertexOffset = primitive.vertexOffset;
    cmd.instanceCount = 1;
    cmd.firstInstance = invocationId;

    visibilityPassData.drawCounts.indirectCount.opaqueCount = 1;
    visibilityPassData.opaqueCommands.commandArray[0] = cmd;
    return;

    if (bTransparent) {
        uint outputIndex = atomicAdd(visibilityPassData.drawCounts.indirectCount.transparentCount, 1);
        visibilityPassData.transparentCommands.commandArray[outputIndex] = cmd;
    } else {
        uint outputIndex = atomicAdd(visibilityPassData.drawCounts.indirectCount.opaqueCount, 1);
        visibilityPassData.opaqueCommands.commandArray[outputIndex] = cmd;
    }
    //}

}