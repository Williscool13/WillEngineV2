#version 460

#include "scene.glsl"

// layout (std140, set = 0, binding = 0) uniform SceneData - scene.glsl

layout (set = 1, binding = 0) uniform sampler2D depthImage;
layout (r16f, set = 1, binding = 1) uniform image2D outDepth0;
layout (r16f, set = 1, binding = 2) uniform image2D outDepth1;
layout (r16f, set = 1, binding = 3) uniform image2D outDepth2;
layout (r16f, set = 1, binding = 4) uniform image2D outDepth3;
layout (r16f, set = 1, binding = 5) uniform image2D outDepth4;

layout (push_constant) uniform PushConstants {
    float depthLinearizeMult;
    float depthLinearizeAdd;

    float radius;
    float radiusMultiplier;
    float falloff;

    vec2 ndcToViewMult;
    vec2 ndcToViewAdd;

    float strength;

    int numDirections;
    int numSteps;

    float spatialFilterRadius;

    float temporalWeight;
} pushConstants;


shared float g_scratchDepths[8][8];

layout(local_size_x = 8, local_size_y = 8) in;

float screenToViewSpaceDepth(float screenDepth, float depthLinearizeMul, float depthLinearizeAdd) {
    // Optimization by XeGTAO
    // https://github.com/GameTechDev/XeGTAO/blob/a5b1686c7ea37788eeb3576b5be47f7c03db532c/Source/Rendering/Shaders/XeGTAO.hlsli#L112
    return depthLinearizeMul / (depthLinearizeAdd - screenDepth);
}

float clampDepth(float depth){
    // using half float precision
    return clamp(depth, 0.0, 65504.0);
}

float depthMipFilter(float depth0, float depth1, float depth2, float depth3, float effectRadius, float radiusMultiplier, float falloffRange){
    float maxDepth = max(max(depth0, depth1), max(depth2, depth3));

    // https://github.com/GameTechDev/XeGTAO/blob/e7698f874e90f2516fca26c696ec3cd2c70e505a/Source/Rendering/Shaders/XeGTAO.hlsli#L583C13-L583C14
    const float depthRangeScaleFactor = 0.75f;// found empirically :)


    const float _effectRadius = depthRangeScaleFactor * effectRadius * radiusMultiplier;
    const float _falloffRange = falloffRange * _effectRadius;
    const float falloffFrom = _effectRadius * (1 - falloffRange);

    const float falloffMul = -1.0 /  _falloffRange;
    const float falloffAdd = falloffFrom / (_falloffRange) + 1.0;

    float weight0 = clamp((maxDepth-depth0) * falloffMul + falloffAdd, 0.0f, 1.0f);
    float weight1 = clamp((maxDepth-depth1) * falloffMul + falloffAdd, 0.0f, 1.0f);
    float weight2 = clamp((maxDepth-depth2) * falloffMul + falloffAdd, 0.0f, 1.0f);
    float weight3 = clamp((maxDepth-depth3) * falloffMul + falloffAdd, 0.0f, 1.0f);

    float weightSum = weight0 + weight1 + weight2 + weight3;
    return (weight0 * depth0 + weight1 * depth1 + weight2 * depth2 + weight3 * depth3) / weightSum;
}

void main() {
    ivec2 screenPos = ivec2(gl_GlobalInvocationID.xy);

    ivec2 dispatchID = ivec2(gl_GlobalInvocationID.xy);
    ivec2 groupThreadID = ivec2(gl_LocalInvocationID.xy);

    // MIP 0
    const ivec2 baseCoord = dispatchID;
    const ivec2 pixCoord = baseCoord * 2;// We process 2x2 pixels in MIP 0

    vec2 uvCoord = vec2(pixCoord) * sceneData.texelSize;

    vec4 depths4;
    depths4.x = texture(depthImage, uvCoord + vec2(0.0, 0.0) * sceneData.texelSize).r;
    depths4.y = texture(depthImage, uvCoord + vec2(1.0, 0.0) * sceneData.texelSize).r;
    depths4.z = texture(depthImage, uvCoord + vec2(0.0, 1.0) * sceneData.texelSize).r;
    depths4.w = texture(depthImage, uvCoord + vec2(1.0, 1.0) * sceneData.texelSize).r;

    float depth0 = clampDepth(screenToViewSpaceDepth(depths4.x, pushConstants.depthLinearizeMult, pushConstants.depthLinearizeAdd));
    float depth1 = clampDepth(screenToViewSpaceDepth(depths4.y, pushConstants.depthLinearizeMult, pushConstants.depthLinearizeAdd));
    float depth2 = clampDepth(screenToViewSpaceDepth(depths4.z, pushConstants.depthLinearizeMult, pushConstants.depthLinearizeAdd));
    float depth3 = clampDepth(screenToViewSpaceDepth(depths4.w, pushConstants.depthLinearizeMult, pushConstants.depthLinearizeAdd));

    imageStore(outDepth0, pixCoord + ivec2(0, 0), vec4(depth0, 0.0f, 0.0f, 0.0f));
    imageStore(outDepth0, pixCoord + ivec2(1, 0), vec4(depth1, 0.0f, 0.0f, 0.0f));
    imageStore(outDepth0, pixCoord + ivec2(0, 1), vec4(depth2, 0.0f, 0.0f, 0.0f));
    imageStore(outDepth0, pixCoord + ivec2(1, 1), vec4(depth3, 0.0f, 0.0f, 0.0f));

    // MIP 1
    float dm1 = depthMipFilter(depth0, depth1, depth2, depth3, pushConstants.radius, pushConstants.radiusMultiplier, pushConstants.falloff);
    imageStore(outDepth1, ivec2(baseCoord), vec4(dm1));
    g_scratchDepths[groupThreadID.x][groupThreadID.y] = dm1;

    memoryBarrierShared();
    barrier();

    // MIP 2
    if (all(equal(groupThreadID.xy % 2u, uvec2(0u)))){
        float inTL = g_scratchDepths[groupThreadID.x+0][groupThreadID.y+0];
        float inTR = g_scratchDepths[groupThreadID.x+1][groupThreadID.y+0];
        float inBL = g_scratchDepths[groupThreadID.x+0][groupThreadID.y+1];
        float inBR = g_scratchDepths[groupThreadID.x+1][groupThreadID.y+1];

        float dm2 = depthMipFilter(inTL, inTR, inBL, inBR, pushConstants.radius, pushConstants.radiusMultiplier, pushConstants.falloff);
        imageStore(outDepth2, ivec2(baseCoord/2u), vec4(dm2));
        g_scratchDepths[groupThreadID.x][groupThreadID.y] = dm2;
    }

    memoryBarrierShared();
    barrier();

    // MIP 3
    if (all(equal(groupThreadID.xy % 4u, uvec2(0u)))){
        float inTL = g_scratchDepths[groupThreadID.x+0][groupThreadID.y+0];
        float inTR = g_scratchDepths[groupThreadID.x+2][groupThreadID.y+0];
        float inBL = g_scratchDepths[groupThreadID.x+0][groupThreadID.y+2];
        float inBR = g_scratchDepths[groupThreadID.x+2][groupThreadID.y+2];

        float dm3 = depthMipFilter(inTL, inTR, inBL, inBR, pushConstants.radius, pushConstants.radiusMultiplier, pushConstants.falloff);
        imageStore(outDepth3, ivec2(baseCoord/4u), vec4(dm3));
        g_scratchDepths[groupThreadID.x][groupThreadID.y] = dm3;
    }

    memoryBarrierShared();
    barrier();

    // MIP 4
    if (all(equal(groupThreadID.xy % 8u, uvec2(0u)))){
        float inTL = g_scratchDepths[groupThreadID.x+0][groupThreadID.y+0];
        float inTR = g_scratchDepths[groupThreadID.x+4][groupThreadID.y+0];
        float inBL = g_scratchDepths[groupThreadID.x+0][groupThreadID.y+4];
        float inBR = g_scratchDepths[groupThreadID.x+4][groupThreadID.y+4];

        float dm4 = depthMipFilter(inTL, inTR, inBL, inBR, pushConstants.radius, pushConstants.radiusMultiplier, pushConstants.falloff);
        imageStore(outDepth4, ivec2(baseCoord/8u), vec4(dm4));
        //g_scratchDepths[groupThreadID.x][groupThreadID.y] = dm4;
    }
}
