#version 460

#include "scene.glsl"

layout(local_size_x = 16, local_size_y = 16) in;

// layout (std140, set = 0, binding = 0) uniform SceneData - scene.glsl

layout (set = 1, binding = 0) uniform sampler2D prefilteredDepth;
layout (set = 1, binding = 1) uniform sampler2D normalBuffer;
layout (r8, set = 1, binding = 2) uniform image2D aoOutput;

layout (push_constant) uniform PushConstants {
    vec2 ndcToViewMult;
    vec2 ndcToViewAdd;

    float depthLinearizeMult;
    float depthLinearizeAdd;

    float radius;
    float falloff;
    float radiusMultiplier;

    float strength;

    int numDirections;
    int numSteps;

    float temporalWeight;
    float spatialFilterRadius;
} pushConstants;

vec4 calculateDepthEdges(const float centerZ, const float leftZ, const float rightZ, const float topZ, const float bottomZ)
{
    vec4 edgesLRTB = vec4(leftZ, rightZ, topZ, bottomZ) - vec4(centerZ);

    float slopeLR = (edgesLRTB.y - edgesLRTB.x) * 0.5;
    float slopeTB = (edgesLRTB.w - edgesLRTB.z) * 0.5;
    vec4 edgesLRTBSlopeAdjusted = edgesLRTB + vec4(slopeLR, -slopeLR, slopeTB, -slopeTB);
    edgesLRTB = min(abs(edgesLRTB), abs(edgesLRTBSlopeAdjusted));

    return clamp((1.25 - edgesLRTB / (centerZ * 0.011)), 0, 1);;
}

void main() {
    // todo: a debug output image that will be used to visualize every step in a separate output image shared by every stage!
    const ivec2 screenPos = ivec2(gl_GlobalInvocationID.xy);
    vec2 uv = (vec2(screenPos) + 0.5) * sceneData.texelSize;

    float viewSpaceZM = textureLod(prefilteredDepth, uv + vec2(0.0, 0.0) * sceneData.texelSize, 0).r;
    float viewSpaceZL = textureLod(prefilteredDepth, uv + vec2(-1.0, 0.0) * sceneData.texelSize, 0).r;
    float viewSpaceZR = textureLod(prefilteredDepth, uv + vec2(1.0, 0.0) * sceneData.texelSize, 0).r;
    float viewSpaceZT = textureLod(prefilteredDepth, uv + vec2(0.0, 1.0) * sceneData.texelSize, 0).r;
    float viewSpaceZB = textureLod(prefilteredDepth, uv + vec2(0.0, -1.0) * sceneData.texelSize, 0).r;

    vec4 edges  = calculateDepthEdges(viewSpaceZM, viewSpaceZL, viewSpaceZR, viewSpaceZT, viewSpaceZB);
    float minEdge = min(min(edges.x, edges.y), min(edges.z, edges.w));
    imageStore(aoOutput, screenPos, vec4(minEdge));

    // Get view space normal by sampling normal buffer and converting from world to view (code not relevant)
    //vec3 viewspaceNormal = (lpfloat3)XeGTAO_CalculateNormal(edgesLRTB, CENTER, LEFT, RIGHT, TOP, BOTTOM);

    // Per Intel: Move center pixel slightly towards camera to avoid imprecision artifacts due to depth buffer imprecision; offset depends on depth texture format used
    viewspaceZM = viewspaceZM * 0.99920f;

    // Get the viewspace fragment position of the center pixel (i.e. reconstruct from depth, but in view space instead of world space)
    // const vec3 pixCenterPos = XeGTAO_ComputeViewspacePosition( normalizedScreenPos, viewspaceZ, consts );
    // const vec3 viewVec = normalize(-pixCenterPos);

    // prevents normals that are facing away from the view vector - xeGTAO struggles with extreme cases, but in Vanilla it seems rare so it's disabled by default
    // viewspaceNormal = normalize( viewspaceNormal + max( 0, -dot( viewspaceNormal, viewVec ) ) * viewVec );
}
